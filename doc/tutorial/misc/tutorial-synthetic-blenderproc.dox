/**

\page tutorial-synthetic-blenderproc Tutorial: Generating synthetic data for deep learning with Blenderproc
\tableofcontents

\section dnn_synthetic_intro Introduction

In this tutorial, we will show how to generate synthetic data that can be used to train a neural network, thanks to blenderproc.

Most of the (manual) work when training a neural network resides in acquiring and labelling data. This process can be slow, tedious and error prone.
A solution to avoid this step is to use synthetic data, generated by a simulator/computer program. This approach comes with multiple advantages:
- Data acquisition is fast
- It is easy to acquire accurate ground truth labels
- Variations in the training data can be easily added

There are however, some drawbacks:
- More knowledge of the scene is required: in the case of detection, we require a 3D model of the object, which is not the case for true images
- A difference between simulated and real data can be apparent and negatively impact network performance (this is called the Sim2Real gap)

The latter point is heavily dependent on the quality of the generated images and the more realistic the images, the better the expected results.

Blender, using ray tracing, can generate realistic images. To perform data generation, <a href="https://github.com/DLR-RM/BlenderProc">Blenderproc</a> has been developed and is an extremely useful and flexible tool to generate realistic scenes from Python code.

Along with RGB images, Blenderproc can generate different labels or inputs:
- Depth map
- Normals
- Semantic segmentation
- Instance segmentation
- Bounding box
- Optical flow (not provided in our generation script)

In this tutorial, we will install blenderproc and use it to generate simple but varied scenes containing objects of interest.
We provide a simple, object-centric generation script that should suffice in many cases.
However, since Blenderproc is easy to use, with many examples included in the <a href="https://dlr-rm.github.io/BlenderProc/index.html">documentation</a>, readapting this script to your needs should be easy.

\section dnn_synthetic_install Requirements

First, you should start by installing blenderproc. First, start by creating a new conda environment to avoid potential conflicts with other Python packages.
\code{.sh}
$ conda create --name blenderproc python=3.10 pip
$ conda activate blenderproc
\endcode
\note Our generation script has been tested with blenderproc 2.5.0 (with Blender 3.3 under the hood) and python 3.10.

You can then run the Blenderproc sample example with:
\code{.sh}
(blenderproc) $ blenderproc quickstart
\endcode
This may take some time, as Blenderproc downloads its own version of Blender and sets up its own environment. This setup will only be performed once.

Once Blenderproc is done, you can check its output with:
\code{.sh}
(blenderproc) $ blenderproc vis hdf5 output/0.hdf5
\endcode

Blenderproc stores its output in HDF5 file format. Each HDF5 **may** contain the RGB image, along with depth, normals, and other modalities.

For the simulator to provide useful data, we should obtain a set of realistic textures (thus helping close the Sim2Real gap).
Thankfully, Blenderproc provides a helpful script to download a dataset of materials from cc0textures.com, containing more than 1500 high resolution materials.
To download the materials, run
\code{.sh}
(blenderproc) $ blenderproc download cc_textures path/to/folder/where/to/save/materials
\endcode
\warning Because the materials are in high definition, downloading the full dataset may take a large amount of disk space (30+ GB). If this is too much for you, you can safely delete some of the materials or stop the script after it has acquired enough materials. While using a small number of materials can be useful when performing quick tests, using the full set should be preferred as variety helps when transferring your deep learning model to real world data.


\section dnn_synthetic_script Running the object-centric generation script

We will now run the generation script.
The script places a random set of objects in a simple cubic room, with added distractors. Materials of the walls and distractors are randomized.

This script and an example configuration file can be found in the `script/dataset_generator` folder of your ViSP <b>source</b> directory.


The basic algorithm is:
\verbatim
For each scene:
  Choose N target objects from the provided models
  Add noise to the N objects (material properties, size, geometry)
  Generate a scene:
    - compute s = length of the larget diagonal of the axis-aligned bounding box of the largest object
    - set room_size = s * random_scale_factor
    - Create the ground, walls and ceiling of the room (with size room_size) and select a random material for each of them
    - Add random distractors, sampled from spheres, cubes, cylinders and monkey heads (Suzanne)
    For each distractor:
      - Sample a random position and orientation in the room
      - Select a random material from cc0
      - Add noise to PBR
      - Potentially add displacement
      - Potentially set distractor as emissive (emitting light)
    - Add random lights, either point lights or spots
    For each light:
      - Sample a random intensity and position
      - Sample a random color
      - If the light is a spot, orient it so that it focuses on a target object
    If simulating physics:
      - Simulate physics for a fixed time and set final object poses
    Remove objects that left the room (Physics collisions)
  Sample camera poses:
    For each sample to generate:
      Do while camera pose is not correct:
        - Select a target object
        - Select a point of interest in the bounding box of the object
        - Sample a random camera location in a clamped ball around the object
          - Camera position is set to have a minimum/maximum distance to the point of interest that is dependent on the object size
        - Set camera orientation to look at the point of interest, with a random rotation around the optical axis
        - Camera pose is correct if target object is visible and camera does not clip through an object or a wall
  - Call blender rendering
  - Save data in HDF5 format
    - If required, compute occlusion-aware bounding boxes
    - If required, save object pose in camera frame
\endverbatim
Many randomization parameters can be modified to alter the rendering, as explained in \ref dnn_input_configuration.



With this simple approach, we can obtain images such as:
\image html misc/blenderproc_rgb_example.png


\subsection dnn_input_objects 3D model format
To use this data generation tool, you should first provide the 3D models.
You can provide multiple models, which will be sampled randomly during generation.

The models should be contained in a folder as such:
\verbatim
- models
  - objectA
    - model.obj
    - model.mtl
    - texture.png
  - objectB
    - another_model.obj
    - another_model.mtl
\endverbatim

When setting up the configuration file in \ref dnn_input_configuration, "models_path" should point to the root folder, models.
Each subfolder should contain a single object, in `.obj` format (with potential materials and textures). Each object will be considered as having its own class, the class name being the name of the subfolder (e.g., objectA or objectB).
The class indices start with 1, and are sorted alphabetically depending on the name of the class (e.g., objectA = 1, objectB = 2).

\subsection dnn_input_configuration Generation configuration
Configuring the dataset generation is done through a JSON file. An example configuration file can be seen below:
\include example_config.json

The general parameters are:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>numpy_seed</td>
    <td>Int</td>
    <td>Seed for numpy's random functions. Allows for reproducible results.</td>
  </tr>
  <tr>
    <td>blenderproc_seed</td>
    <td>String</td>
    <td>Seed for Blenderproc. Allows for reproducible results.</td>
  </tr>
  <tr>
    <td>models_path</td>
    <td>String</td>
    <td>Path to the folder containing the models. See \ref dnn_input_objects</td>
  </tr>
  <tr>
    <td>cc_textures_path</td>
    <td>String</td>
    <td>Path to the folder containing the CC0 materials.</td>
  </tr>
</table>

You can also control some of the rendering parameters. This will impact the rendering time and the quality of the generated RGB images.
These parameters are located in the "rendering" field.
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>max_num_samples</td>
    <td>Int > 0</td>
    <td>Number of rays per pixels. A lower number results in noisier images (especially in scenes with large variations).</td>
  </tr>
  <tr>
    <td>denoiser</td>
    <td>One of [null, "INTEL", "OPTIX"]</td>
    <td>Which denoiser to use after performing ray tracing. null indicates that no denoiser is used. "OPTIX" requires a compatible Nvidia GPU.
    Using a denoiser allows to obtain a clean image, with a low number of rays per pixels.</td>
  </tr>
</table>

You can also modify the camera's intrinsic parameters. The camera uses an undistorted perspective projection model. For more information on camera parameters, see vpCameraParameters.
These parameters are found in the "camera" field of the configuration.
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>px</td>
    <td>float</td>
    <td>See vpCameraParameters</td>
  </tr>
  <tr>
    <td>py</td>
    <td>float</td>
    <td>See vpCameraParameters</td>
  </tr>
  <tr>
    <td>v0</td>
    <td>float</td>
    <td>See vpCameraParameters</td>
  </tr>
  <tr>
    <td>u0</td>
    <td>float</td>
    <td>See vpCameraParameters</td>
  </tr>
  <tr>
    <td>h</td>
    <td>Int</td>
    <td>Height of the generated images.</td>
  </tr>
  <tr>
    <td>w</td>
    <td>Int</td>
    <td>Width of the generated images.</td>
  </tr>
  <tr>
    <td>randomize_params_percent</td>
    <td>float, [0, 1)</td>
    <td>
      Controls the randomization of the camera parameters \f$p_x, p_y, u_0, v_0\f$. If randomize_params_percent > 0, then, each time a scene is created the intrinsics are perturbed around the given values.
      For example, if this parameters is equal to 10 and \f$p_x = 500\f$, then the used \f$p_x\f$ when generating images will be in the range [450, 550].
    </td>
  </tr>
</table>


To customize the scene, you can change the parameters in the "scene" field:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>room_size_multiplier_min</td>
    <td>float > 1.0, < room_size_multiplier_max</td>
    <td>
      Minimum room size as a factor of the biggest sampled target object. The room is cubic.
      The size of the biggest object is the length of the largest diagonal of its axis-aligned bounding box. This tends to overestimate the size of the object.
      If the size of the biggest object is 0.5m, room_size_multiplier_max = 2 and room_size_multiplier_max = 4, then the room's size will be randomly sampled to be between 1m and 2m.
    </td>
  </tr>
  <tr>
    <td>room_size_multiplier_max</td>
    <td>float > room_size_multiplier_min</td>
    <td>
      Minimum room size as a factor of the biggest sampled target object. The room is cubic.
      The size of the biggest object is the length of the largest diagonal of its axis-aligned bounding box. This tends to overestimate the size of the object.
      If the size of the biggest object is 0.5m, room_size_multiplier_max = 2 and room_size_multiplier_max = 4, then the room's size will be randomly sampled to be between 1m and 2m.
    </td>
  </tr>

  <tr>
    <td>simulate_physics</td>
    <td>Boolean</td>
    <td>Whether to simulate physics. If false, then objects will be floating across the room. If true, then objects will fall to the ground.</td>
  </tr>
  <tr>
    <td>max_num_textures</td>
    <td>Int > 0</td>
    <td>Max number of textures per blenderproc run. If scenes_per_run is 1, max_num_textures = 50 and the number of distractors is more than 50, then the 50 textures will be used across all distractors (and walls). In this case, new materials will be sampled for each scene.</td>
  </tr>
  <tr>
    <td>distractors</td>
    <td>Dictionary</td>
    <td>See below</td>
  </tr>
  <tr>
    <td>lights</td>
    <td>Dictionary</td>
    <td>See below</td>
  </tr>
  <tr>
    <td>objects</td>
    <td>Dictionary</td>
    <td>See below</td>
  </tr>
</table>

Distractors are small, simple objects that are added along with the target objects to create some variations and occlusions.
To modify their properties, you can change the "distractors" field of the scene
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>min_count</td>
    <td>Int >= 0, < max_count</td>
    <td>
      Minimum number of distractors to place in the room.
    </td>
  </tr>
  <tr>
    <td>max_count</td>
    <td>Int > min_count</td>
    <td>
      Maximum number of distractors to place in the room.
    </td>
  </tr>
  <tr>
    <td>min_size_rel_scene</td>
    <td>float > 0.0</td>
    <td>
      Minimum size of the distractors, relative to the room size.
      If the room size is 0.5m and min_size_rel_scene = 0.1, then the minimum size of distractor will be 0.05m.
      Scale is applied independently on each axis.
    </td>
  </tr>
  <tr>
    <td>max_size_rel_scene</td>
    <td>float < 1.0, > min_size_rel_scene</td>
    <td>
      maximum size of the distractors, relative to the room size.
      If the room size is 0.5m and max_size_rel_scene = 0.2, then the maximum size of distractor will be 0.1m.
      Scale is applied independently on each axis.
    </td>
  </tr>
  <tr>
    <td>displacement_max_amount</td>
    <td>float >= 0.0 </td>
    <td>
      Amount of displacement to apply to distractors.
      Displacement subdivides the mesh and displaces each of the distractor's vertices according to a random noise pattern.
      <b>This option greatly slows down rendering: set it to 0 if needed.</b>
    </td>
  </tr>
  <tr>
    <td>pbr_noise</td>
    <td>float >= 0.0 </td>
    <td>
      Amount of noise to add to the material properties of the distractors.
      These properties include the specularity, the "metallicness" and the roughness of the material, according to Blender's principled BSDF.
    </td>
  </tr>
  <tr>
    <td>emissive_prob</td>
    <td>float >= 0.0 , <= 1.0</td>
    <td>
      Probability that a distractor becomes a light source: its surface emits light. Set to more than 0 to add more light variations and shadows.
    </td>
  </tr>
  <tr>
    <td>emissive_min_strength</td>
    <td>float >= 0.0, < emissive_max_strength</td>
    <td>
      Minimum emission strength for a distractor that emits lights. In Watts/m².
    </td>
  </tr>
  <tr>
    <td>emissive_max_strength</td>
    <td>float > emissive_min_strength</td>
    <td>
      Maxmimum emission strength for a distractor that emits lights. In Watts/m².
    </td>
  </tr>
</table>

To change the lighting behaviour, see the options below:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>min_count</td>
    <td>Int >= 0, < max_count</td>
    <td>
      Minimum number of lights in the scene.
    </td>
  </tr>
  <tr>
    <td>max_count</td>
    <td>Int > min_count</td>
    <td>
      Maximum number of lights in the scene
    </td>
  </tr>
  <tr>
    <td>min_intensity</td>
    <td>float > 0.0, < max_intensity</td>
    <td>
      Minimum intensity of a light. In Watts.
    </td>
  </tr>
  <tr>
    <td>max_intensity</td>
    <td>float > min_intensity</td>
    <td>
      Maximum intensity of a light. In Watts.
    </td>
  </tr>
</table>

To change the sampling behaviour of target objects, see the properties below:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>min_count</td>
    <td>Int >= 0, < max_count</td>
    <td>
      Minimum number of target objects in the scene.
    </td>
  </tr>
  <tr>
    <td>max_count</td>
    <td>Int > min_count</td>
    <td>
      Maximum number of target objects in the scene.
    </td>
  </tr>
  <tr>
    <td>multiple_occurences</td>
    <td>Boolean</td>
    <td>
      Whether a single object can appear multiple times in the same scene (sampling with replacement).
    </td>
  </tr>
  <tr>
    <td>scale_noise</td>
    <td>float >= 0.0</td>
    <td>
      Object size noise. if scale_noise > 0.0, the object is scaled uniformly on all axes (it does not appear stretched)
    </td>
  </tr>
  <tr>
    <td>displacement_max_amount</td>
    <td>float >= 0.0 </td>
    <td>
      Amount of displacement to apply to target objects.
      Displacement subdivides the mesh and displaces each of the distractor's vertices according to a random noise pattern.
      <b>This option greatly slows down rendering: set it to 0 if needed.</b>
      Note that this is in absolute units: and does not vary depending on the size of the object.
    </td>
  </tr>
  <tr>
    <td>pbr_noise</td>
    <td>float >= 0.0 </td>
    <td>
      Amount of noise to add to the material properties of the target objects.
      These properties include the specularity, the "metallicness" and the roughness of the material, according to Blender's principled BSDF.
    </td>
  </tr>
  <tr>
    <td>cam_min_dist_rel</td>
    <td>float >= 0.0, < cam_max_dist_rel </td>
    <td>
      Minimum distance of the camera to the point of interest of the object when sampling camera poses. This is expressed in terms of the size of the target object.
      If the target object has a size of 0.5m and cam_min_dist_rel = 1.5, then the closest possible camera will be at 0.75m away from the point of interest.
    </td>
  </tr>
  <tr>
    <td>cam_max_dist_rel</td>
    <td>float >= cam_min_dist_rel</td>
    <td>
      Maximum distance of the camera to the point of interest of the object when sampling camera poses. This is expressed in terms of the size of the target object.
      If the target object has a size of 0.5m and cam_max_dist_rel = 2.0, then the farthest possible camera will be 1m away from the point of interest.
    </td>
  </tr>
</table>

Finally, we can customize the dataset that we will generate from the given scenes.
This includes the number of scenes, images, and what information to save.

All the data will be stored in HDF5 format, which can then be unpacked later.

To customize the dataset, modify the options in the "dataset" field:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>save_path</td>
    <td>String</td>
    <td>Path to the folder that will contain the final dataset. This folder will contain one folder per scene, and each sample of a scene will be its own HDF5 file.</td>
  </tr>
  <tr>
    <td>scenes_per_run</td>
    <td>Int > 0</td>
    <td>
      Number of scenes to generate per blenderproc run. Between blenderproc runs, Blender is restarted in order to avoid memory issues.
    </td>
  </tr>
  <tr>
    <td>num_scenes</td>
    <td>Int > 0</td>
    <td>
      Total number of scenes to generate. Generating many scenes will add more diversity to the dataset as object placement, materials and lighting are randomized once per scene.
    </td>
  </tr>
  <tr>
    <td>images_per_scene</td>
    <td>Int > 0</td>
    <td>
      Number of images to generate per scene. The total number of samples in the dataset will be num_scenes * images_per_scene.
    </td>
  </tr>
  <tr>
    <td>pose</td>
    <td>Boolean</td>
    <td>
      Whether to save the pose of target objects that are visible in the camera. The pose of the objects are expressed in the camera frame as an homogeneous matrix \f$^{c}\mathbf{T}_{o}\f$
    </td>
  </tr>
  <tr>
    <td>depth</td>
    <td>Boolean</td>
    <td>
      Whether to save the depth buffer associated to the RGB image. Same size as the RGB image.
    </td>
  </tr>
  <tr>
    <td>normals</td>
    <td>Boolean</td>
    <td>
      Whether to save the normal map associated to the RGB image. Same size as the RGB image.
      The normals are 3D unit vectors, expressed in the camera frame.
    </td>
  </tr>
  <tr>
    <td>segmentation</td>
    <td>Boolean</td>
    <td>
      Whether to save the segmentation maps (by class and by instance).
      Segmentation by class only contains the target objects (class >= 1).
      Segmentation by instance includes every visible object.
    </td>
  </tr>
  <tr>
    <td>detection</td>
    <td>Boolean</td>
    <td>
      Whether to save the bounding box detections. In this case, bounding boxes are not computed from the segmentation map (also possible with Blenderproc), but rather in way such that occlusion does not influence the final bounding box.
      The detections can be filtered with the parameters in "detection_params".
    </td>
  </tr>
  <tr>
    <td>detection_params:min_size_size_px</td>
    <td>Int > 0</td>
    <td>
      Minimum side length of a detection for it to be considered as valid. Used to filter really far or small objects, for which detection would be hard.
    </td>
  </tr>
  <tr>
    <td>detection_params:min_visibility</td>
    <td>float [0.0, 1.0]</td>
    <td>
      Percentage of the object that must be visible for a detection to be considered as valid. The visibility score is computed as such:
      First, the vertices of the mesh that are behind the camera are filtered. Then, the vertices that are outside of the camera's field of view are filtered. Then, we randomly sample "detection_params:points_sampling_occlusion" points to test whether the object is occluded (test done through ray casting).
      If too many points are filtered, then the object is considered as not visible and detection is invalid.
    </td>
  </tr>
</table>


\section dnn_run_script Running the script to generate data

\code{.sh}
(blenderproc) $ python
\endcode


\section dnn_output Using and parsing the generation output

\subsection dnn_output_yolov7 Using detections to train a YoloV7

\subsection dnn_output_custom_parsing Parsing HDF5 with a custom script

link tuto blenderproc


\section dnn_synthetic_next Next steps


*/
