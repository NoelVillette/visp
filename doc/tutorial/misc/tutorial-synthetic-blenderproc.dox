/**

\page tutorial-synthetic-blenderproc Tutorial: Generating synthetic data for deep learning with Blenderproc
\tableofcontents

\section dnn_synthetic_intro Introduction

In this tutorial, we will show how to generate synthetic data that can be used to train a neural network, thanks to blenderproc.

Most of the (manual) work when training a neural network resides in acquiring and labelling data. This process can be slow, tedious and error prone.
A solution to avoid this step is to use synthetic data, generated by a simulator/computer program. This approach comes with multiple advantages:
- Data acquisition is fast
- It is easy to acquire accurate ground truth labels
- Variations in the training data can be easily added

There are however, some drawbacks:
- More knowledge of the scene is required: in the case of detection, we require a 3D model of the object, which is not the case for true images
- A difference between simulated and real data can be apparent and negatively impact network performance (this is called the Sim2Real gap)

The latter point is heavily dependent on the quality of the generated images and the more realistic the images, the better the expected results.

Blender, using ray tracing, can generate realistic images. To perform data generation, <a href="https://github.com/DLR-RM/BlenderProc">Blenderproc</a> has been developed and is an extremely useful and flexible tool to generate realistic scenes from Python code.

Along with RGB images, Blenderproc can generate different labels or inputs:
- Depth map
- Normals
- Semantic segmentation
- Instance segmentation
- Bounding box
- Optical flow (not provided in our generation script)

In this tutorial, we will install blenderproc and use it to generate simple but varied scenes containing objects of interest.
We provide a simple, object-centric generation script that should suffice in many cases.
However, since Blenderproc is easy to use, with many examples included in the <a href="https://dlr-rm.github.io/BlenderProc/index.html">documentation</a>, readapting this script to your needs should be easy.

\section dnn_synthetic_install Requirements

First, you should start by installing blenderproc. First, start by creating a new conda environment to avoid potential conflicts with other Python packages.
\code{.sh}
$ conda create --name blenderproc python=3.10 pip
$ conda activate blenderproc
\endcode
\note Our generation script has been tested with blenderproc 2.5.0 (with Blender 3.3 under the hood) and python 3.10.

You can then run the Blenderproc sample example with:
\code{.sh}
(blenderproc) $ blenderproc quickstart
\endcode
This may take some time, as Blenderproc downloads its own version of Blender and sets up its own environment. This setup will only be performed once.

Once Blenderproc is done, you can check its output with:
\code{.sh}
(blenderproc) $ blenderproc vis hdf5 output/0.hdf5
\endcode

Blenderproc stores its output in HDF5 file format. Each HDF5 **may** contain the RGB image, along with depth, normals, and other modalities. 

For the simulator to provide useful data, we should obtain a set of realistic textures (thus helping close the Sim2Real gap).
Thankfully, Blenderproc provides a helpful script to download a dataset of materials from cc0textures.com, containing more than 1500 high resolution materials.
To download the materials, run
\code{.sh}
(blenderproc) $ blenderproc download cc_textures path/to/folder/where/to/save/materials
\endcode
\warning Because the materials are in high definition, downloading the full dataset may take a large amount of disk space (30+ GB). If this is too much for you, you can safely delete some of the materials or stop the script after it has acquired enough materials. While using a small number of materials can be useful when performing quick tests, using the full set should be preferred as variety helps when transferring your deep learning model to real world data.


\section dnn_synthetic_script Running the object-centric generation script

We will now run the generation script. 
The script places a random set of objects in a simple cubic room, with added distractors. Materials of the walls and distractors are randomized.

The basic algorithm is:
\verbatim
For each scene:
  Choose N target objects from the provided models
  Add noise to the N objects (material properties, size, geometry)
  Generate a scene:
    - compute s = length of the larget diagonal of the axis-aligned bounding box of the largest object
    - set room_size = s * random_scale_factor
    - Create the ground, walls and ceiling of the room (with size room_size) and select a random material for each of them
    - Add random distractors, sampled from spheres, cubes, cylinders and monkey heads (Suzanne)
    For each distractor:
      - Sample a random position and orientation in the room
      - Select a random material from cc0
      - Add noise to PBR
      - Potentially add displacement
      - Potentially set distractor as emissive (emitting light)
    - Add random lights, either point lights or spots
    For each light:
      - Sample a random intensity and position
      - Sample a random color
      - If the light is a spot, orient it so that it focuses on a target object
    If simulating physics:
      - Simulate physics for a fixed time and set final object poses
    Remove objects that left the room (Physics collisions)
  Sample camera poses:
    For each sample to generate:
      Do while camera pose is not correct:
        - Select a target object
        - Select a point of interest in the bounding box of the object
        - Sample a random camera location in a clamped ball around the object
          - Camera position is set to have a minimum/maximum distance to the point of interest that is dependent on the object size
        - Set camera orientation to look at the point of interest, with a random rotation around the optical axis
        - Camera pose is correct if target object is visible and camera does not clip through an object or a wall
  - Call blender rendering
  - Save data in HDF5 format
    - If required, compute occlusion-aware bounding boxes
    - If required, save object pose in camera frame
\endverbatim
Many randomization parameters can be modified to alter the rendering, as explained in \ref dnn_input_configuration.

With this simple approach, we can obtain images such as:
\image html misc/blenderproc_rgb_example.png


\subsection dnn_input_objects 3D model format
To use this data generation tool, you should first provide the 3D models.
You can provide multiple models, which will be sampled randomly during generation.

The models should be contained in a folder as such:
\verbatim
- models
  - objectA
    - model.obj
    - model.mtl
    - texture.png
  - objectB
    - another_model.obj
    - another_model.mtl
\endverbatim

When setting up the configuration file in \ref dnn_input_configuration, "models_path" should point to the root folder, models.
Each subfolder should contain a single object, in `.obj` format (with potential materials and textures). Each object will be considered as having its own class, the class name being the name of the subfolder (e.g., objectA or objectB).
The class indices start with 1, and are sorted alphabetically depending on the name of the class (e.g., objectA = 1, objectB = 2).

\subsection dnn_input_configuration Generation configuration
Configuring the dataset generation is done through a JSON file. An example configuration file can be seen below:
\include example_config.json

The general parameters are:
<table>
  <tr><th>Name</th><th>Type, possible values</th><th>Description</th></tr>
  <tr>
    <td>numpy_seed</td>
    <td>Int</td>
    <td>Seed for numpy's random functions. Allows for reproducible results.</td>
  </tr>
  <tr>
    <td>blenderproc_seed</td>
    <td>String</td>
    <td>Seed for Blenderproc. Allows for reproducible results.</td>
  </tr>
  <tr>
    <td>models_path</td>
    <td>String</td>
    <td>Path to the folder containing the models. See \ref dnn_input_objects</td>
  </tr>
  <tr>
    <td>cc_textures_path</td>
    <td>String</td>
    <td>Path to the folder containing the CC0 materials.</td>
  </tr>
</table>




\section dnn_output Using and parsing the generation output

\subsection dnn_output_yolov7 Using detections to train a YoloV7

\subsection dnn_output_custom_parsing Parsing HDF5 with a custom script

link tuto blenderproc


\section dnn_synthetic_next Next steps


*/
