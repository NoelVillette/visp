Modifying the bindings through JSON configuration files
========================================================

The bindings and the generated code can be customized through JSON configuration files.
These files will be read and interpreted by the generator code.

They are located in the :code:`modules/python/config` folder of the ViSP source code.
After modifying them, you should retrigger the build of the python bindings.

When something cannot be resolved through configuration files, you should revert to using a :ref:`Custom binding`.


Root configuration file
---------------------------------------

The general configuration file is generated by the build system (CMake), it contains the arguments to the generator script.

It contains:

* The list of include directories used when compiling ViSP C++. They are used to resolve include of 3rd parties and find the **vpConfig.h** file

* A set of preprocessor macros that will be used when parsing C++ files with the generator. These are system and compiler dependent.

* For each module (core, imgproc, etc.), the list of header files that should be parsed.


A module can be ignored through the **CMakeLists.txt** configuration of the python module.

Each module has a dedicated JSON configuration file, located in the :code:`modules/python/config` folder.


Module configuration
--------------------------------------------

Configuration files have a top-down structure: First come the general module options,
then class/enum options, and for each of those, method/value configurations.

Module-level options
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: json

  {
    "required_headers": ["visp3/core/vpPoint.h"],
    "ignored_headers": ["vpGEMM.h", "vpDebug.h"],
    "ignored_classes": ["vpException", "vpImageException"],
    "user_defined_headers": ["core.hpp"],
    "enums": {},
    "classes": {},
    "functions": {}
  }


.. list-table:: Parameters
   :header-rows: 1

   * - Name
     - Type
     - Explanation
   * - :code:`required_headers`
     - List of strings
     - List of full header paths. These headers are forcefully included. Should be used if for some reason, the already included ViSP headers are not sufficient.
       By default, each parsed header is added to the includes of this module's binding source (.cpp file compiled with PyBind).
   * - :code:`ignored_headers`
     - List of strings
     - List of header file names, not including the module path. Each of these headers will be **completely** skipped.
       No preprocessing, no parsing, no binding generation. Useful if a header generates errors on parsing.
   * - :code:`ignored_classes`
     - List of strings
     - List of C++ class names (without any template argument).
       These classes will be ignored (but still parsed, unlike with :code:`ignored_headers`) and no binding code generated.
   * - :code:`user_defined_headers`
     - List of strings
     - Paths to user-defined bindings that will be called when generating the overall bindings
       (see class options and :ref:`Custom binding`). These paths are relative to the **modules/python/bindings/include** folder.
       If a file does not exist, an error will be raised at compile time.
   * - :code:`enums`
     - Dictionary
     - Mapping from C++ enum name to an :ref:`enum configuration <Enum options>`.
   * - :code:`classes`
     - Dictionary
     - Mapping from C++ class name (untemplated) to a :ref:`class configuration <Class options>`.
   * - :code:`functions`
     - List of dictionaries
     - List of :ref:`function configuration <Function options>`. These are for free functions, not class methods.


.. warning::
  Exceptions are not handled: they should always be placed in :code:`ignored_classes`.

  When a ViSP exception is thrown to the Python interpreter, it is converted to a RuntimeError


.. _Enum options:
Enum-level options
^^^^^^^^^^^^^^^^^^^

If an enum does not appear in the configuration dictionary, it takes on the default values of each option.

For enums there is only a single option: :code:`"ignore"`, which is a boolean.
If this flag is true, no binding is generated for this enum. The default value is **false**.


.. note::

  By design, all exported ViSP enumerations are of the arithmetic kind.
  It is thus possible to do :python:`Enum.value1 | Enum.value2`.
  Not all enumerations should actually behave like this,
  but it is not trivial to automatically determine which require arithmetic capabalities.

  A possible improvement would be to add an :code:`arithmetic` flag to the configuration options to handle this.

.. _Class options:
Class-level options
^^^^^^^^^^^^^^^^^^^

If a class does not appear in the configuration dictionary, it takes on the default value of each option.


.. code-block:: json
  "ignored_attributes": ["myAttribute"]
  "additional_bindings": "bindings_vpArray2D",
  "use_buffer_protocol": true,
  "specializations": [
    {
      "python_name": "ArrayDouble2D",
      "arguments": ["double"]
    }
  ]
  "ignore_repr": true,
  "is_virtual": true,
  "methods": {}


.. list-table:: Parameters
   :header-rows: 1

   * - Name
     - Type
     - Explanation
   * - :code:`ignored_attributes`
     - List of strings
     - List of attribute names. Each of the corresponding attributes will be ignored when generating binding code.
       By default, binding code is generated only for public fields that are not pointers or other hard to translate types.
   * - :code:`additional_bindings`
     - String
     - Name of a C++ function, defined in **User-defined binding code**.
       Should be visible from the module's .cpp file and have to correct signature.
       This means that the header file in which it is defined should be included in :code:`user_defined_headers`.
       See :ref:`Custom binding` for more info.
   * - :code:`use_buffer_protocol`
     - Boolean
     - Whether to add the buffer protocol to this object. This is a PyBind specific thing,
       and is helpful to automatically interpret an object of this class as an iterable/array (e.g., list) on the python side.
       This should be defined by hand in user-defined bindings. See the
       `Pybind documentation <https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html#buffer-protocol>`_
       for more info.

   * - :code:`specializations`
     - List of dictionaries
     - Only required for templated classes. Templating does not exist in Python, and Pybind can only generate bindings for
       classes that are fully specialized. Thus, it is required to declare the specializations.
       A specialization contains: the Python name of the class as well as the C++ types that will replace the generic template typenames.
       The C++ types should be in the same order as the template parameters.
   * - :code:`ignore_repr`
     - Boolean
     - In python the :python:`__repr__` method is equivalent to the :code:`operator<<(std::ostream&, Cls& self)` function
       allowing to print an object in the terminal. By default, the generator tries to find the C++ defined operator to generate a Python representation.
       If this is not desired, set this flag to true. You can define a custom representation through custom bindings.

       .. warning::
          Long to string representations (matrices, images) can flood the terminal.
          This is problematic if this happens when Pybind throws an error for an incorrect method call
   * - :code:`is_virtual`
     - Boolean
     - Whether to force this class to be considered as purely virtual (cannot be instanciated in Python)

       .. note::
          While most purely virtual classes are correctly detected, classes that inherit from an abstract one
          but do not implement its methods are not correctly detected, which will raise an error at compile time.
          It is for these cases that this flag is required.
   * - :code:`methods`
     - List of dictionaries
     - List of :ref:`function configuration <Function options>`.


.. _Function options:
Function-level options
^^^^^^^^^^^^^^^^^^^
